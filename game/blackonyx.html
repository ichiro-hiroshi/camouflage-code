<script>

var DEBUG = {
	viewer : null,
	init : function() {
		var div = document.createElement('DIV');
		with (div.style) {
			marginLeft = '50%';
			height = '89%';
			overflowY = 'scroll';
			color = 'white';
			backgroundColor = 'black';
			fontFamily = 'monospace';
		}
		document.body.appendChild(div);
		this.viewer = div;
	},
	text : function(in_text) {
		if (!this.viewer) {
			return;
		}
		var div = document.createElement('DIV');
		div.textContent = in_text;
		this.viewer.insertBefore(div, this.viewer.firstChild);
	},
	obj : function(in_obj) {
		if (!this.viewer) {
			return;
		}
		for (var prop in in_obj) {
			switch (typeof in_obj[prop]) {
			case 'string' :
			case 'number' :
				this.text(prop + ' : ' + in_obj[prop]);
				break;
			default :
				break;
			}
		}
	}
};

var NODECTL = {
	dirs : {
		u : {
			bit : 0x01,
			dx  : 0,
			dy  : -1
		},
		r : {
			bit : 0x02,
			dx  : 1,
			dy  : 0
		},
		d : {
			bit : 0x04,
			dx  : 0,
			dy  : 1
		},
		l : {
			bit : 0x08,
			dx  : -1,
			dy  : 0
		}
	},
	dydx2dir : function(in_dy, in_dx) {
		for (var dir in this.dirs) {
			if ((in_dy == this.dirs[dir].dy) && (in_dx == this.dirs[dir].dx)) {
				return dir;
			}
		}
	},
	dydx2bit : function(in_dy, in_dx) {
		return this.dirs[this.dydx2dir(in_dy, in_dx)].bit;
	}
};

var gCanvas = {
	rows : 5,
	cols : 3,
	canvas : null,
	canvasH : 300,
	canvasW : 400,
	floor1 : [],
	floor2 : [],
	/*
		 - - -  : front[0]
		| | | | : side[0]
		 - - -  : front[1]
		| | | | : side[1]
		 - - -  : front[2]
		| | | | : side[2]
	*/
	front : [],
	side : [],
	y2x : function(in_start_x, in_y) {
		/*
			(y1, x1) = (0, in_start_x)
			(y2, x2) = (canvasH, canvasW - in_start_x)
			---
			y = a * (x - b)
			a = y / (x - b) = canvasH / (canvasW - in_start_x * 2)
		*/
		return in_y * (this.canvasW - in_start_x * 2) / this.canvasH + in_start_x;
	},
	init_canvas : function() {
		this.canvas = document.createElement('CANVAS');
		this.canvas.height = this.canvasH;
		this.canvas.width = this.canvasW;
	},
	pointTable : function() {
		var _r1 = 2 / 3;
		var _r2 = 1 / 3;
		var cell_w = this.canvasW / this.cols;
		var point_table = [];
		for (var row = 0; row <= this.rows; row++) {
			var tmp = [];
			var y = (1 - Math.pow(_r1, row)) * (this.canvasH * _r2);
			for (var col = 0; col <= this.cols; col++) {
				var start_x = cell_w * col;
				var x = this.y2x(start_x, y);
				tmp.push([y, x]);
			}
			point_table.push(tmp);
		}
		/*
		for (var row = 0; row < point_table.length; row++) {
			for (var col = 0; col < point_table[row].length; col++) {
				var point = point_table[row][col];
				DEBUG.text('(' + point[0] + ',' + point[1] + ')');
			}
		}
		*/
		return point_table;
	},
	init_floor : function(point_table) {
		for (var row = 0; row < point_table.length - 1; row++) {
			this.floor1[row] = [];
			this.floor2[row] = [];
			for (var col = 0; col < point_table[row].length - 1; col++) {
				var p11 = point_table[row][col];
				var p12 = point_table[row][col + 1];
				var p13 = point_table[row + 1][col + 1];
				var p14 = point_table[row + 1][col];
				this.floor1[row].push([p11, p12, p13, p14]);
				var p21 = [(this.canvasH - p11[0]), p11[1]];
				var p22 = [(this.canvasH - p12[0]), p12[1]];
				var p23 = [(this.canvasH - p13[0]), p13[1]];
				var p24 = [(this.canvasH - p14[0]), p14[1]];
				this.floor2[row].push([p21, p22, p23, p24]);
			}
		}
		this.floor1.reverse();
		this.floor2.reverse();
	},
	init_front : function(point_table) {
		for (var row = 1; row < point_table.length; row++) {
			this.front[row - 1] = [];
			for (var col = 0; col < point_table[row].length - 1; col++) {
				var p1 = point_table[row][col];
				var p2 = point_table[row][col + 1];
				var p3 = [(this.canvasH - p2[0]), p2[1]];
				var p4 = [(this.canvasH - p1[0]), p1[1]];
				this.front[row - 1].push([p1, p2, p3, p4]);
			}
		}
		this.front.reverse();
	},
	init_side : function(point_table) {
		for (var row = 0; row < point_table.length - 1; row++) {
			this.side[row] = [];
			for (var col = 0; col < point_table[row].length; col++) {
				var p1 = point_table[row][col];
				var p2 = point_table[row + 1][col];
				var p3 = [(this.canvasH - p2[0]), p2[1]];
				var p4 = [(this.canvasH - p1[0]), p1[1]];
				this.side[row].push([p1, p2, p3, p4]);
			}
		}
		this.side.reverse();
	},
	init : function() {
		this.init_canvas();
		var point_table = this.pointTable();
		this.init_floor(point_table);
		this.init_front(point_table);
		this.init_side(point_table);
		document.body.appendChild(this.canvas);
		var ctx = this.canvas.getContext('2d');
		for (var row = 0; row < this.floor1.length; row++) {
			for (var col = 0; col < this.floor1[row].length; col++) {
				var depth = Math.ceil(255 * (row + 1) / this.floor1.length);
				drawPolygon(ctx, this.floor1[row][col], 'rgba(0, 0, ' + depth + ', 1)', 'rgba(0, 0, 0, 1)');
				drawPolygon(ctx, this.floor2[row][col], 'rgba(0, 0, ' + depth + ', 1)', 'rgba(0, 0, 0, 1)');
			}
		}
		for (var row = 0; row < this.side.length; row++) {
			for (var col = 0; col < this.side[row].length; col++) {
				var depth = Math.ceil(255 * (row + 1) / this.side.length);
				drawPolygon(ctx, this.side[row][col], 'rgba(0, 0, ' + depth + ', 1)', 'rgba(0, 0, 0, 1)');
			}
		}
		for (var row = 0; row < this.front.length; row++) {
			for (var col = 0; col < this.front[row].length; col++) {
//				drawPolygon(ctx, this.front[row][col], null, 'rgba(0, 0, 0, 1)');
			}
		}
	},
	drawWall : function(in_front, in_side) {
		if (this.rows != in_front.length) {
			return;
		}
		if (this.rows != in_side.length) {
			return;
		}
		if (this.cols != in_front[0].length) {
			return;
		}
		if (this.cols + 1 != in_side[0].length) {
			return;
		}
		var ctx = this.canvas.getContext('2d');
		for (var row = 0; row < this.rows; row++) {
			for (var col = 0; col < this.cols; col++) {
				if (in_front[row][col]) {
					drawPolygon(ctx, this.front[row][col]);
				}
			}
			for (var col = 0; col < this.cols + 1; col++) {
				if (in_side[row][col]) {
					drawPolygon(ctx, this.side[row][col]);
				}
			}
		}
	},
}

function drawPolygon(ctx, point_list, color, bordercolor)
{
	ctx.beginPath();
	for (var i = 0; i < point_list.length; i++) {
		var p = point_list[i];
		if (i == 0) {
			ctx.moveTo(p[1], p[0]);
		} else {
			ctx.lineTo(p[1], p[0]);
		}
	}
	ctx.closePath();
	ctx.strokeStyle = bordercolor;
	ctx.stroke();
	if (color) {
		ctx.fillStyle = color;
		ctx.fill();
	}
}

var gMap = {
	dat : [
	/*
		[0, 0, 0, 0, ... ],
		[0, 0, 0, 0, ... ],
		...
	*/
	],
	pos : {
	/*
		x : 0,
		y : 0,
		dx : 0,
		dy : 0
	*/
	},
	debugDisp : function() {
		for (var y = this.dat.length - 1; y >= 0; y--) {
			var text = '';
			for (var x = 0; x < this.dat[y].length; x++) {
				if ((y == this.pos.y) && (x == this.pos.x)) {
					text += '[' + NODECTL.dydx2dir(this.pos.dy, this.pos.dx) + ']';
				} else {
					text += '[ ]';
				}
			}
			DEBUG.text(text);
		}
	},
	makeWallTbl : function(in_rows, in_cols) {
		/*
			returns this object :
			{
				// (in_rows) entries
				side : {
					[ (in_cols + 1) entries ],
					[ (in_cols + 1) entries ],
					...
				},
				// (in_rows) entries
				front : {
					[ (in_cols) entries ],
					[ (in_cols) entries ],
					...
				}
			}
		*/
	},
	makeView : function() {
		var rows = 3;
		var cols = 3;
		var canvas_h = 400;
		var canvas_w = 600;
		var wall = this.makeWallTbl(rows, cols);
		// ã‰º•`‰æ
		// front[0] •`‰æ, side[0] •`‰æ, ...
	},
	checkFront : function() {
		var y = this.pos.y + this.pos.dy;
		var x = this.pos.x + this.pos.dx;
		if ((y < 0) || (this.dat.length - 1 < y)) {
			return false;
		}
		if ((x < 0) || (this.dat[y].length - 1 < x)) {
			return false;
		}
		if (this.dat[this.pos.y][this.pos.x] & NODECTL.dydx2bit(this.pos.dy, this.pos.dx)) {
			return true;
		} else {
			return false;
		}
	},
	updatePos : function(in_keycode) {
		switch (in_keycode) {
		/* go ahead */
		case 38 :
			if (!this.checkFront()) {
				return;
			} else {
				this.pos.y += this.pos.dy;
				this.pos.x += this.pos.dx;
			}
			break;
		/* turn left */
		case 37 :
			var dir = {
				u : 'l',
				r : 'u',
				d : 'r',
				l : 'd'
			}[NODECTL.dydx2dir(this.pos.dy, this.pos.dx)];
			this.pos.dy = NODECTL.dirs[dir].dy;
			this.pos.dx = NODECTL.dirs[dir].dx;
			break;
		/* turn right */
		case 39 :
			var dir = {
				u : 'r',
				r : 'd',
				d : 'l',
				l : 'u'
			}[NODECTL.dydx2dir(this.pos.dy, this.pos.dx)];
			this.pos.dy = NODECTL.dirs[dir].dy;
			this.pos.dx = NODECTL.dirs[dir].dx;
			break;
		default :
			break;
		}
	},
};

window.addEventListener('load', function(in_e) {
//	DEBUG.init();
	gCanvas.init();
}, false);

window.addEventListener('keydown', function(in_e) {
	DEBUG.text(in_e.keyCode);
	gMap.updatePos(in_e.keyCode);
	gMap.debugDisp();
}, false);

var MAPDATA = {
	dat : [
		'+-+-+-+',
		'|@|@@@@',
		'+@+-+-+',
		'@@|@|@|',
		'+-+-+@+',
		'|@|@|@|',
		'+-u-+@+',
	],
	value : function(in_y, in_x) {
		if ((in_y < 0) || (this.dat.length - 1 < in_y)) {
			return '@';
		}
		if ((in_x < 0) || (this.dat[in_y].length - 1 < in_x)) {
			return '@';
		}
		return this.dat[in_y].substr(in_x, 1);
	}
};

/*
                        (y * 2 - 1, x * 2)
    (y * 2, x * 2 - 1)  (y * 2,     x * 2)  (y * 2, x * 2 + 1)
                        (y * 2 + 1, x * 2)
*/

for (var y = 0; y < (MAPDATA.dat.length + 1) / 2; y++) {
	gMap.dat[y] = [];
	for (var x = 0; x < (MAPDATA.dat[y].length + 1) / 2; x++) {
		var arround = {
			c : {y : y * 2,     x : x * 2    },
			u : {y : y * 2 - 1, x : x * 2    },
			r : {y : y * 2,     x : x * 2 + 1},
			d : {y : y * 2 + 1, x : x * 2    },
			l : {y : y * 2,     x : x * 2 - 1}
		};
		for (var dir in arround) {
			var value = MAPDATA.value(arround[dir].y, arround[dir].x);
			switch (value) {
			case 'u' :
			case 'r' :
			case 'd' :
			case 'l' :
				/* arround.[c] */
				gMap.pos.y = y;
				gMap.pos.x = x;
				gMap.pos.dy = NODECTL.dirs[value].dy;
				gMap.pos.dx = NODECTL.dirs[value].dx;
				break;
			case '|' :
			case '-' :
				/* arround.[urdl] */
				gMap.dat[y][x] |= NODECTL.dirs[dir].bit;
				break;
			case '@' :
			default :
				/* arround.[urdl] */
				break;
			}
		}
	}
}

</script>
